<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake Game</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    body {
      background-color: #f8f9fa;
      font-family: Arial, sans-serif;
    }
    .game-container {
      max-width: 800px;
      margin: 2rem auto;
      padding: 2rem;
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    #snakeCanvas {
      border: 2px solid #000;
      display: block;
      margin: 1rem auto;
      background-color: #fafafa;
    }
    .scoreboard {
      margin-top: 1rem;
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 5px;
    }
    .message {
      margin: 1rem 0;
      padding: 1rem;
      border-radius: 5px;
      display: none;
    }
    .message.success {
      background-color: #d4edda;
      color: #155724;
    }
    .message.error {
      background-color: #f8d7da;
      color: #721c24;
    }
    #endGameScreen {
      display: none;
      margin-top: 2rem;
      padding: 1rem;
      border: 2px solid #28a745;
      border-radius: 10px;
      background-color: #d4edda;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h2>Snake Game - Room <span id="roomIdLabel"></span></h2>
    <div class="d-flex justify-content-between align-items-center">
      <div>Round: <span id="roundNumber">1</span></div>
      <!-- If you don't want a timer, you can remove this or keep it for the round # -->
    </div>

    <canvas id="snakeCanvas" width="400" height="400"></canvas>

    <!-- Direction controls for quick testing (or use arrow keys) -->
    <div class="mt-3">
      <button id="moveUp" class="btn btn-secondary btn-sm">Up</button>
      <button id="moveLeft" class="btn btn-secondary btn-sm">Left</button>
      <button id="moveRight" class="btn btn-secondary btn-sm">Right</button>
      <button id="moveDown" class="btn btn-secondary btn-sm">Down</button>
    </div>

    <div id="message" class="message"></div>

    <div class="scoreboard">
      <h5>Scoreboard</h5>
      <div id="scoresList"></div>
    </div>

    <div id="endGameScreen">
      <h3>Game Over!</h3>
      <div id="endGameDetails"></div>
      <button id="restartButton" class="btn btn-primary mt-3">Play Again</button>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    const tileSize = 20; // Each cell is 20px
    const gridWidth = canvas.width / tileSize;
    const gridHeight = canvas.height / tileSize;

    let socket;
    let currentUser;
    let currentRoom;

    // Local representation of game state
    let gameState = {
      snakes: {}, // { playerId: { body: [[x,y],...], alive: bool, score: number } }
      food: [0, 0],
      roundNumber: 1
    };

    // 1) Initialize or get current user
    currentUser = JSON.parse(localStorage.getItem('currentUser') || "null");
    if (!currentUser || !currentUser.id) {
      const id = prompt("Enter your player id:");
      currentUser = { id };
      localStorage.setItem('currentUser', JSON.stringify(currentUser));
    }

    // 2) Parse roomId from URL
    const params = new URLSearchParams(window.location.search);
    currentRoom = params.get('roomId');
    document.getElementById('roomIdLabel').textContent = currentRoom || 'N/A';

    // Initialize socket
    socket = io('http://localhost:2053');

    socket.on('connect', () => {
      console.log("Socket connected:", socket.id);
      // Join the room
      if (currentRoom) {
        socket.emit('joinRoomSocket', {
          roomId: currentRoom,
          playerId: currentUser.id
        });
      }
    });

    socket.on('disconnect', () => {
      console.log("Socket disconnected");
    });

    socket.on('error', (err) => {
      console.error("Socket error:", err);
    });

    // Listen for newRound
    socket.on('newRound', (data) => {
      console.log("Received newRound:", data);
      document.getElementById('roundNumber').textContent = data.roundNumber || 1;
      showMessage(`Round ${data.roundNumber} started!`, 'success');
    });

    // Listen for gameStateUpdate
    socket.on('gameStateUpdate', (data) => {
      // data = { state: {...}, scores: {...} }
      if (data.state) {
        gameState = data.state;
      }
      updateScoreboard(data.scores);
      renderGame();
    });

    // Listen for roundEnded
    socket.on('roundEnded', (data) => {
      console.log("Received roundEnded:", data);
      showMessage(`Round ended! Reason: ${data.reason}`, 'error');
      updateScoreboard(data.scores);
    });

    // Listen for gameEnded
    socket.on('gameEnded', (data) => {
      console.log("Received gameEnded:", data);
      // Show endgame screen
      const endGameScreen = document.getElementById('endGameScreen');
      endGameScreen.style.display = 'block';

      let html = `<p><strong>Reason:</strong> ${data.reason}</p>`;
      if (data.standings && data.standings.length) {
        const winner = data.standings[0];
        html += `<p><strong>Winner:</strong> ${winner.playerData.username || winner.playerId} (Score: ${winner.score})</p>`;
        if (data.standings.length > 1) {
          html += `<h5>Other Standings:</h5>`;
          data.standings.slice(1).forEach((player) => {
            html += `<p>Player ${player.playerId}: ${player.score} pts</p>`;
          });
        }
      }
      document.getElementById('endGameDetails').innerHTML = html;
    });

    // "Move" buttons
    document.getElementById('moveUp').addEventListener('click', () => emitMove('up'));
    document.getElementById('moveLeft').addEventListener('click', () => emitMove('left'));
    document.getElementById('moveRight').addEventListener('click', () => emitMove('right'));
    document.getElementById('moveDown').addEventListener('click', () => emitMove('down'));

    // Optional: handle arrow keys to move
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') emitMove('up');
      if (e.key === 'ArrowDown') emitMove('down');
      if (e.key === 'ArrowLeft') emitMove('left');
      if (e.key === 'ArrowRight') emitMove('right');
    });

    // Restart button (reload or implement different logic)
    document.getElementById('restartButton').addEventListener('click', () => {
      window.location.reload();
    });

    function emitMove(direction) {
      if (currentRoom && currentUser) {
        socket.emit('gameAction', {
          roomId: currentRoom,
          playerId: currentUser.id,
          action: {
            type: 'move',
            direction
          }
        });
      }
    }

    function showMessage(text, type) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.className = `message ${type}`;
      msg.style.display = 'block';
    }

    function updateScoreboard(scores) {
      const scoresList = document.getElementById('scoresList');
      const entries = Object.entries(scores || {});
      if (entries.length === 0) {
        scoresList.innerHTML = '<p>No scores yet</p>';
        return;
      }

      let html = '';
      entries.forEach(([pid, score]) => {
        html += `<p>Player ${pid}: ${score} pts</p>`;
      });
      scoresList.innerHTML = html;
    }

    function renderGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the food
      if (gameState.food) {
        ctx.fillStyle = 'red';
        ctx.fillRect(
          gameState.food[0] * tileSize,
          gameState.food[1] * tileSize,
          tileSize,
          tileSize
        );
      }

      // Draw each snake
      if (gameState && gameState.snakes) {
        Object.entries(gameState.snakes).forEach(([playerId, snakeData]) => {
          if (!snakeData.alive) return; // if you want to skip 'dead' snakes
          snakeData.body.forEach((segment, index) => {
            const [x, y] = segment;
            // Head a different color maybe
            ctx.fillStyle = index === 0 ? 'green' : 'lime';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          });
        });
      }
    }
  </script>
</body>
</html>
